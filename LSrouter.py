####################################################
# LSrouter.py
# Name: Doan Van Giap, Tran Hau Nam
# HUID:
#####################################################

from router import Router
from packet import Packet
import json
import heapq

INFINITY = 16 

class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.seq_num = 0
        self.lsdb = {} # {router_addr: {'seq': num, 'links': {neighbor: cost}}}
        self.neighbors = {} # {port: {'addr': addr, 'cost': cost}}
        self.forwarding_table = {} # {dest_addr: next_hop_port}    
        # Initialize LSDB
        self.lsdb[self.addr] = {'seq': self.seq_num, 'links': {}}

    def broadcast_lsp(self):
        # Broadcasts LSP to all neighbors
        lsp_content = {
            'src': self.addr,
            'seq': self.seq_num,
            'links': self.lsdb[self.addr]['links']
        }
        # Chỉ gửi LSP đến neighbors
        if self.neighbors:
            lsp_packet = Packet(Packet.ROUTING, self.addr, "*", json.dumps(lsp_content))
            for port in self.neighbors.keys():
                self.send(port, lsp_packet)
            
    def run_dijkstra(self):
        all_known_nodes = set()
        for src, data in self.lsdb.items():
            all_known_nodes.add(src)
            all_known_nodes.update(data['links'].keys())
        
        dist = {node: INFINITY for node in all_known_nodes}
        prev = {node: None for node in all_known_nodes}
        
        # Đảm bảo nút nguồn có trong tập hợp và dist
        if self.addr not in dist:
            all_known_nodes.add(self.addr)
            dist[self.addr] = INFINITY
            prev[self.addr] = None
             
        dist[self.addr] = 0
        
        pq = [(0, self.addr)] # (cost, node)

        while pq:
            d, u = heapq.heappop(pq)
            
            if d > dist.get(u, INFINITY): 
                continue
                
            # Duyệt qua các láng giềng của u từ LSDB
            # Chỉ các router mới có entry trong LSDB, client chỉ là đích
            if u in self.lsdb:
                for v, cost in self.lsdb[u]['links'].items():
                    # Chỉ cập nhật nếu v có trong all_known_nodes (và do đó có trong dist/prev)
                    if v in dist and dist.get(u, INFINITY) + cost < dist.get(v, INFINITY):
                        dist[v] = dist[u] + cost
                        prev[v] = u
                        heapq.heappush(pq, (dist[v], v))

        new_forwarding_table = {}
        for dest in all_known_nodes:
            # Không cần đường đi đến chính mình hoặc nếu không thể đến được
            if dest == self.addr or prev.get(dest) is None:
                # Trừ khi đó là láng giềng trực tiếp mà không có prev (trường hợp đặc biệt)
                if dest != self.addr and dest in self.lsdb[self.addr]['links'] and prev.get(dest) is None:
                    pass
                else:
                    continue

            curr = dest
            # Tìm bước nhảy đầu tiên bằng cách đi ngược từ đích về nguồn
            while prev.get(curr) is not None and prev[curr] != self.addr:
                curr = prev[curr]
            
            first_hop = curr
            # Tìm cổng tương ứng với bước nhảy đầu tiên
            for port, neighbor_info in self.neighbors.items():
                if neighbor_info['addr'] == first_hop:
                    new_forwarding_table[dest] = port
                    break

        self.forwarding_table = new_forwarding_table

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dst_addr == self.addr:
                pass
            elif packet.dst_addr in self.forwarding_table:
                next_port = self.forwarding_table[packet.dst_addr]
                self.send(next_port, packet)
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            lsp_data = json.loads(packet.content)
            src_addr = lsp_data['src']
            seq = lsp_data['seq']
            links = lsp_data['links']
            if src_addr != self.addr and (src_addr not in self.lsdb or seq > self.lsdb[src_addr]['seq']):
                self.lsdb[src_addr] = {'seq': seq, 'links': links}
                self.run_dijkstra()
                for p, neighbor_info in self.neighbors.items():
                    if p != port:
                        self.send(p, packet)

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        self.neighbors[port] = {'addr': endpoint, 'cost': cost}
        self.lsdb[self.addr]['links'][endpoint] = cost
        self.seq_num += 1
        self.lsdb[self.addr]['seq'] = self.seq_num
        
        self.broadcast_lsp()
        self.run_dijkstra()

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        if port in self.neighbors:
            endpoint = self.neighbors[port]['addr']

            del self.neighbors[port]

            if endpoint in self.lsdb[self.addr]['links']:
                 del self.lsdb[self.addr]['links'][endpoint]
            self.seq_num += 1
            self.lsdb[self.addr]['seq'] = self.seq_num

            self.broadcast_lsp()
            self.run_dijkstra()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the link state of this router to all neighbors
            self.broadcast_lsp()

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr})"
